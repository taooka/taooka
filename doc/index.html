<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    

    <link rel="apple-touch-icon" sizes="180x180" href="http://taooka.com/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http://taooka.com/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://taooka.com/favicon-16x16.png">
    <link rel="manifest" href="http://taooka.com/manifest.json">
    <link rel="mask-icon" href="http://taooka.com/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <link rel="canonical" href="http://taooka.com/doc/">

    <title>
      
      
         Documentation 
      
    </title>
    <style>
  * {
    border:0;
    font:inherit;
    font-size:100%;
    vertical-align:baseline;
    margin:0;
    padding:0;
    color: black;
  }

  body {
    font-family:'Open Sans', 'Myriad Pro', Myriad, sans-serif;
    font-size:17px;
    line-height:160%;
    color:#1d1313;
    max-width:700px;
    margin:auto;
  }

  p {
    margin: 20px 0;
  }

  a img {
    border:none;
  }

  img {
    margin: 10px auto 10px auto;
    max-width: 100%;
    display: block;
  }

  pre, code {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    background-color: #f7f7f7;
  }

  code {
    font-size: 12px;
    padding: 4px;
  }

  pre {
    margin-top: 0;
    margin-bottom: 16px;
    word-wrap: normal;
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
  }

  pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
  }

  pre code {
    display: inline;
    max-width: auto;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
  }

  pre code::before,
  pre code::after {
    content: normal;
  }

  em,q,em,dfn {
    font-style:italic;
  }

  .sans,html .gist .gist-file .gist-meta {
    font-family:"Open Sans","Myriad Pro",Myriad,sans-serif;
  }

  .mono,pre,code,tt,p code,li code {
    font-family:Menlo,Monaco,"Andale Mono","lucida console","Courier New",monospace;
  }

  .heading,.serif,h1,h2,h3 {
    font-family:"Old Standard TT",serif;
  }

  strong {
    font-weight:600;
  }

  q:before {
    content:"\201C";
  }

  q:after {
    content:"\201D";
  }

  del,s {
    text-decoration:line-through;
  }

  blockquote {
    font-family:"Old Standard TT",serif;
    text-align:center;
    padding:50px;
  }

  blockquote p {
    display:inline-block;
    font-style:italic;
  }

  blockquote:before,blockquote:after {
    font-family:"Old Standard TT",serif;
    content:'\201C';
    font-size:35px;
    color:#403c3b;
  }

  blockquote:after {
    content:'\201D';
  }

  hr {
    width:40%;
    height: 1px;
    background:#403c3b;
    margin: 25px auto;
  }

  h1 {
    font-size:35px;
  }

  h2 {
    font-size:28px;
  }

  h3 {
    font-size:22px;
    margin-top:18px;
  }

  h1 a,h2 a,h3 a {
    text-decoration:none;
  }

  h1,h2 {
    margin-top:28px;
  }

  #sub-header, time {
    color:#403c3b;
    font-size:13px;
  }

  #sub-header {
    margin: 0 4px;
  }

  #nav h1 a {
    font-size:35px;
    color:#1d1313;
    line-height:120%;
  }

  .posts_listing a,#nav a {
    text-decoration: none;
  }

  li {
    margin-left: 20px;
  }

  ul li {
    margin-left: 5px;
  }

  ul li {
    list-style-type: none;
  }
  ul li:before {
    content:"\00BB \0020";
  }

  #nav ul li:before, .posts_listing li:before {
    content:'';
    margin-right:0;
  }

  #content {
    text-align:left;
    width:100%;
    font-size:15px;
    padding:60px 0 80px;
  }

  #content h1,#content h2 {
    margin-bottom:5px;
  }

  #content h2 {
    font-size:25px;
  }

  #content .entry-content {
    margin-top:15px;
  }

  #content time {
    margin-left:3px;
  }

  #content h1 {
    font-size:30px;
  }

  .highlight {
    margin: 10px 0;
  }

  .posts_listing {
    margin:0 0 50px;
  }

  .posts_listing li {
    margin:0 0 25px 15px;
  }

  .posts_listing li a:hover,#nav a:hover {
    text-decoration: underline;
  }

  #nav {
    text-align:center;
    position:static;
    margin-top:60px;
  }

  #nav ul {
    display: table;
    margin: 8px auto 0 auto;
  }

  #nav li {
    list-style-type:none;
    display:table-cell;
    font-size:15px;
    padding: 0 20px;
  }

  #links {
    margin: 50px 0 0 0;
  }

  #links :nth-child(2) {
    float:right;
  }

  #not-found {
    text-align: center;
  }

  #not-found a {
    font-family:"Old Standard TT",serif;
    font-size: 200px;
    text-decoration: none;
    display: inline-block;
    padding-top: 225px;
  }

  @media (max-width: 750px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:28px;
    }

    #nav li {
      font-size:13px;
      padding: 0 15px;
    }

    #content {
      margin-top:0;
      padding-top:50px;
      font-size:14px;
    }

    #content h1 {
      font-size:25px;
    }

    #content h2 {
      font-size:22px;
    }

    .posts_listing li div {
      font-size:12px;
    }
  }

  @media (max-width: 400px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:22px;
    }

    #nav li {
      font-size:12px;
      padding: 0 10px;
    }

    #content {
      margin-top:0;
      padding-top:20px;
      font-size:12px;
    }

    #content h1 {
      font-size:20px;
    }

    #content h2 {
      font-size:18px;
    }

    .posts_listing li div{
      font-size:12px;
    }
  }
</style>

  </head>

  <body>
    <section id=nav>
      <ul>
        
          <li><a href="http://taooka.com/doc/">Docs</a></li>
        
          <li><a href="http://taooka.com/download/">Download</a></li>
        
          <li><a href="http://taooka.com/blog/">Blog</a></li>
        
          <li><a href="http://taooka.com/contact/">Contact</a></li>
        
      </ul>
      <h1><a href="http://taooka.com/"><img src="http://taooka.com/logo.png">Taooka</a></h1>
      <h2>Add some consistency to a distributed system</h2>
    </section>


<section id=content>
  <h1> Documentation </h1>
  <div class="entry-content">
    

<h1 id="installation">Installation</h1>

<h2 id="linux">Linux</h2>

<p>install:</p>

<pre><code>$ wget http://taooka.com/dl/latest/taooka_amd64.deb
$ sudo dpkg -i taooka_amd64.deb
$ taooka -h
$ taooka
</code></pre>

<p>uninstall:</p>

<pre><code>sudo dpkg -r taooka
</code></pre>

<h2 id="docker">Docker</h2>

<p><a href="https://hub.docker.com/r/taooka/taooka/">Docker image</a>, <a href="https://github.com/taooka/docker-taooka/blob/master/docker/Dockerfile">Dockerfile</a></p>

<p><code>docker pull taooka/taooka</code></p>

<p><code>docker run -d -p 127.0.0.1:15663:15663/udp taooka/taooka</code></p>

<h1 id="client-server-interaction">Client-server interaction</h1>

<p>Таука взаимодействует с клиентами по UDP. Это позволяет продолжать работать даже при большом количестве потерь пакетов в сети, не тратить время и ресурсы на создание TCP-соединения и его последующее поддержание.</p>

<p>Клиент подключается к серверу, отправляя CONNECT-запрос. Сервер отправляет OPTIONS-ответ, содержащий уникальный номер соединения. Все последующие запросы содержат этот номер соединения, а так же последовательный номер запроса. Таким образом каждый запрос к серверу имеет уникальный номер. Ответ от сервера содержит тот же самый уникальный номер. Это позволяет отсеивать дублирующиеся запросы на сервере и клиенте, не бояться повторно отправить запрос или ответ, а сам протокол сделать асинхронным. Т.е. через одно соединение отправляется несколько запросов, а потом ответы на них приходят в произвольном порядке ибо ясно на какой запрос пришёл каждый ответ.</p>

<p>Все запросы и ответы имеют контрольную сумму, и поэтому защищены от порчи во время передачи по сети.</p>

<p>После завершения работы с сервером соедиение желательно закрыть.</p>

<h1 id="locking">Locking</h1>

<p>Таука позволяет выполнять следующие операции с блокировками:</p>

<ul>
<li>Lock(Key, TTL) устанавливает блокировку для ключа key на время TTL;</li>
<li>Update(TTL) обновляет у существующей блокировки TTL;</li>
<li>Unlock() снимает существующую блокировку;</li>
<li>UnlockAll() снимает все существующие блокировки.</li>
</ul>

<p>Update(TTL) удобен тем, что позволяет изначально при блокировке задавать небольшое значение TTL и потом периодически продлевать его. Малый TTL позволяет быстрее проэкпариться блокировке в случае, если сломался установивший её клиент, а значит другие процессы быстрее смогут получить эту блокировку.</p>

<p>UnlockAll() удобен при администрировании. Например, чтобы снять блокировки, установленные без TTL. Но надо учитывать, что после этой команды все клиенты, которые имеют установленные блокировки, будут изолированы, ибо их блокировки пропадают, другие клиенты их могут установить, и без изоляции получится, что два клиента захватили одну блокировку.</p>

<h1 id="client-isolation">Client isolation</h1>

<p>Для недопущения взятия одной блокировки несколькими клиентами в случае истечения времени жизни блокировки, установивший её клиент подлежит изоляции от внешнего мира. Изолированный клиент может продолжать работать некоторое время, но не должен никак повлиять ни на какие-либо данные, с которыми он или другие клиенты работают. Для корректной работы изоляции клиент должен передать Тауке данные о себе. Передаются они при соединении с сервером. Это обычный текст, который сохраняется Таукой и потом подаётся в <code>STDIN</code> программы изоляции. Так, например, клиент может сообщить имя хоста, на котором он запущен и свой <code>PID</code>. Также в Тауке нужно указать путь до программы или скрипта, выполняющегог изоляцию: <code>-path-to-block-script</code>. Программа изоляции пишется администратором и может работать следующим образом: попытаться зайти на хост и выполнить <code>kill -9</code> для указанного процесса. Если сделать это не получилось, то на время добавить ip хоста в чёрный список firewall-ов серверов, хранящих данные. Потом переодически пытаться заходить на хост и пытаться сделать <code>kill -9</code> процессу клиента. А как это получится, убрать ip хоста и завершить свою работу с exit code равным нулю. Если программа изоляции вернула exit code отличный от нуля, она будет запущена для этого клиента снова. Подробнее вопрос изоляции рассмотрен в статье &ldquo;<a href="http://taooka.com/blog/how-does-the-distributed-lock-manager-work/"> Как работает менеджер распределённых блокировок.</a>&rdquo;.</p>

<h1 id="server">Server</h1>

<p>Сервер состоит из нескольких независимых модулей.</p>

<h2 id="configuration-module">Configuration module</h2>

<p>Загружает настройки Тауки из файла конфигурации (пока не реализовано), а если переданы параметры командной строки, то использует их вместо данных из файла конфигурации. На текущий момент определены следующие параметры командной строки:</p>

<pre><code>  -journal-dir string
        The path to journal directory. Example: -journal-dir=&quot;/opt/taooka&quot;.
  -journal-sync-write
        Write journal synchronously. Example: -journal-sync-write.
  -path-to-block-script string
        The path to the script that blocks the ip of the remote client with the expired lock. Example: -path-to-block-script=&quot;/usr/local/taooka/bin/block-remote-client.sh&quot;.
  -pause-before-isolate duration
        How long to wait before isolating the client with the expired lock. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;µs&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;. Example: -pause-before-isolate=&quot;1m30s&quot;.
  -pause-on-startup-before-checking-ttl duration
        How long to wait at startup before finding expired locks. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;µs&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;. Example: -pause-on-startup-before-checking-ttl=&quot;10m&quot;.
  -product-key string
        The product key that was purchased. Example: -product-key=&quot;1234-5678-9012-3456&quot;.
  -server-addr string
        The address for client requests. Example: -server-addr=&quot;192.168.1.2:15663&quot;. (default &quot;localhost:15663&quot;)
</code></pre>

<p>В версии для разработчиков журнал отсуствует и никакие файлы на диск не пишутся. Соотвественно опции -journal-dir и -journal-sync-write отсуствуют.</p>

<h2 id="server-module">Server module</h2>

<p>Отвечает за обработку новых соединений с клиентами, получение, парсинг и проверку корректности запросов, отправку ответов.</p>

<h2 id="fsm-module">FSM module</h2>

<p>FSM (Finite State Machine) хранит в оперативной памяти информацию о текущих блокировках и подключённых клиентах. Изменяет своё состояние на основании запросов от Server module и сохраняет его через Journal module. В случае истечения времени жизни блокировки запускает процесс изоляции клиента, её установившего, если изоляция настроена и клиент передал информацию о его изоляции.</p>

<h2 id="journal-module">Journal module</h2>

<p>Отвечает за сохранение состояния FSM на диске в файлах журнала, удаление устаревшей информации из них и загрузку состояния при старте Тауки. Журнал может работать в трёх режимах:</p>

<ul>
<li>Отключённый журнал позволяеть достигать минимально возможного latency, ибо не нужно ждать, пока данные запишутся на диск, прежде чем ответить клиенту.</li>
<li>Асинхронная запись файлов журнала позволяет сохранять состояние FSM между рестартами Тауки, при этом достигая небольших значений latency.</li>
<li>Синхронная запись файлов журнала. При условии использования серверных версий HDD и SSD, позволяет сохранять состояние FSM даже при непредвиденных отключениях питания, но ценой этого будут большие задержки. Для их сокращения рекомендуется использовать SSD вместо HDD.</li>
</ul>

<p>Запись и чтение файлов журнала всегда ведётся последовательно, что позволяет достичь максимальной производительности.</p>

<h2 id="node-module-ещё-не-реализован">Node module (ещё не реализован)</h2>

<p>Отвечает за репликацию FSM на другие ноды кластера.</p>

<h2 id="log-module-ещё-не-реализован">Log module (ещё не реализован)</h2>

<p>Записывает информацию об ошибках в работе Тауки.</p>

<h2 id="monitoring-module-частично-реализован">Monitoring module (частично реализован)</h2>

<p>Отображает текущее состояние Тауки.</p>

<h1 id="performanсe-tuning">Performanсe tuning</h1>

<h2 id="network-tuning">Network tuning</h2>

<p>Таука обменивается данными с клиентами по UDP, а поэтому работает тем быстрее, чем меньше пакетов тереятся. Поэтому основная цель тюнинга сети контроль за очередями, в которых бывают пакеты прежде чем попасать от клиента к серверу.</p>

<p>Чаще всего отправка пакетов значительно более дешёвая операция, чем приём пакетов, но и её можно ускорить. Когда клиент отправляет UDP-пакет, то он сначала попадает в очередь сокета, а потом в на отправку сетевой карты. В современных сетевых картах очередей несколько и, чтобы CPU не конкурировали за доступ к ним, имеет смысл настроить <a href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">XPS</a> .</p>

<p>Приём пакетов значительно более ресурсоёмкий. Cуществует три очереди, где пакет последовательно оказывается, прежде чем дойдёт до приложения: очередь сетевой карты, очередь сокета и очередь приложения. Если в какой-либо из очередей нет места, то пакет отбрасывается. Поэтому можно порекомендовать увеличить размер этих очередей, дабы пакеты не терялись в случае кратковременных пиковых нагрузок. Размер очереди у сетевой карты увеливается через <code>ethtool</code>. Увеличение размера очереди сокета описано <a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">тут</a>. Taука пытаемся максимально быстро вычитывать пакеты из очереди сокета. Размер её очереди значителен и позволяет сглаживать кратковременные пики нагрузки.</p>

<p>Для корректной работы с каждой очередью каждому ядру процессора её сначала требуется заблокировать, записать в неё, а потом снять блокировку. Поэтому, чем больше ядер одновременно пытаются записать в одну ит ту же очередь, тем меньше производительность. В идеале каждое ядро должно читать из одной очереди и писать тоже в одну очередь.</p>

<p>Очень упрощённо приём пакетов работает следующим образом. Сетевая карта при приходе пакета отправляет операционной системе прерывание, говорящее о том, что пакет надо прочитать из сетевой карты. Когда пакетов приходит много, то операционная система включает непрерывное вычитывание пакетов из сетевой карты и негенерит SoftIRQ. Лишь когда очередь опустошается, опять включает приём обычных прерываний IRQ. Т.о. создаётся много SoftIRQ прерываний, и процессор занят только их обработкой. Если у процессора несколько ядер, то желательно распределить SoftIRQ по всем процессорам. В современных сетевых картах несколько очередей на приём пакетов: <code>ls -l /sys/class/net/eth0/queues/</code>. В некоторых сетевых картах их количество можно регулировать через <code>ethtool</code>. Привязав каждую из очередей к определённому ядру процессора, можно распределить нагрузку между ядрами, свести к нулю блокировки и эффективнее использовать кэши каждого ядра. Для этого используются <a href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">RSS и RPS</a></p>

<p>Попав в операционную систему пакет должен записаться в сокет, которому он адресован. Если сокет один, то несколько ядрер для записи в него будут использовать блокировки и бороться за запись. Для предотвращения этой борьбы в Тауке вместо одного сокета открывается несколько по числу ядер. Также для всех их задаётся <a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">BPF</a>-программа, которая сопоставляет каждый сокет со строго одним ядром процессора. Так мы добиваемся, чтобы пакеты как можно быстрее попадали из сетевой карты в Тауку, не терясь по дороге.</p>

<p>В случае использования контейнеров рекомендуется ознакомиться со статьёй <a href="http://machinezone.github.io/research/networking-solutions-for-kubernetes/">&ldquo;Comparison of networking solutions for Kubernetes&rdquo;</a>.</p>

<h2 id="disc-tuning">Disc tuning</h2>

<p>Скорость записи на диск напрямую влияет на latency, ибо при включённом журнале Таука сначала должна записать на диск, а только потом ответить. Поэтому, мы рекомендуем использовать SSD в случае, если задержки Вас не устраивают. SSD так же как и сетевая карта может создавать много SoftIRQ. Поэтому их также рекомендуется распределить по ядрам.</p>

  </div>
</section>

  
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-85639-18', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</body>
</html>
